//go:build scheduler.softstack
// +build scheduler.softstack

package task

import "unsafe"

//go:linkname runtimePanic runtime.runtimePanic
func runtimePanic(str string)

// Stack canary, to detect a stack overflow. The number is a random number
// generated by random.org. The bit fiddling dance is necessary because
// otherwise Go wouldn't allow the cast to a smaller integer size.
const stackCanary = uintptr(uint64(0x670c1333b83bf575) & uint64(^uintptr(0)))

// state is a structure which holds a reference to the state of the task.
// When the task is suspended, the rewind chain is stored into windchain.
type state struct {
	fn        func()
	sp        unsafe.Pointer
	windchain unsafe.Pointer
	canaryPtr *uintptr
}

//go:extern (internal/task).sp
var sp unsafe.Pointer

//go:extern (internal/task).windchain
var windchain unsafe.Pointer

// Pause suspends the current task and returns to the scheduler.
// This function may only be called when running on a goroutine stack, not when running on the system stack or in an interrupt.
//go:noinline
func Pause() {
	if windchain == nil {
		if sp == nil {
			runtimePanic("cannot pause outside of a goroutine")
		}

		// Start the unwind process by setting windchain.
		// Use the windchain to save the current stack pointer.
		windchain = sp
	} else {
		// Restore the stack pointer (discarding the saves used to rewind).
		sp = windchain

		// Terminate the rewind process by clearing windchain.
		windchain = nil
	}
}

// currentTask is the current running task, or nil if currently in the scheduler.
var currentTask *Task

// Current returns the current active task.
func Current() *Task {
	return currentTask
}

//go:linkname runqueuePushBack runtime.runqueuePushBack
func runqueuePushBack(*Task)

// start creates and starts a new goroutine with the given function and arguments.
// The new goroutine is scheduled to run later.
func start(fn uintptr, args unsafe.Pointer, stackSize uintptr) {
	// Create a stack.
	stack := make([]uintptr, stackSize/unsafe.Sizeof(uintptr(0)))

	// Set up the stack canary, a random number that should be checked when
	// switching from the task back to the scheduler. The stack canary pointer
	// points to the first word of the stack. If it has changed between now and
	// the next stack switch, there was a stack overflow.
	canaryPtr := &stack[0]
	*canaryPtr = stackCanary

	// Compute the initial stack pointer.
	sp := unsafe.Pointer(uintptr(unsafe.Pointer(&stack[0])) + uintptr(len(stack))*unsafe.Sizeof(uintptr(0)))

	// Create a function value from the arguments.
	// TODO: make this function just acccept a function value as an argument instead
	fnVal := struct {
		ctx   unsafe.Pointer
		fnptr uintptr
	}{
		ctx:   args,
		fnptr: fn,
	}

	// Initialize a new task.
	t := &Task{
		state: state{
			fn:        *(*func())(unsafe.Pointer(&fnVal)),
			sp:        sp,
			canaryPtr: canaryPtr,
		},
	}

	// Queue the task to run.
	runqueuePushBack(t)
}

// Resume the task until it pauses or completes.
// This may only be called from the scheduler.
//go:noinline
func (t *Task) Resume() {
	if sp != nil {
		runtimePanic("cannot resume a goroutine while inside another goroutine")
	}

	currentTask = t
	sp = t.state.sp
	windchain = t.state.windchain
	t.state.fn()
	if *t.state.canaryPtr != stackCanary {
		runtimePanic("goroutine stack overflow")
	}
	t.state.windchain = windchain
	sp = nil
	windchain = nil
	currentTask = nil
}

// OnSystemStack returns whether the caller is running on the system stack.
func OnSystemStack() bool {
	return true
}
